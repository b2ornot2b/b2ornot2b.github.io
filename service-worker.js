// Generated by CoffeeScript 1.9.2
var cache_version, current_caches, log, version,
  slice = [].slice;

version = '0.0.1';

log = function() {
  var args;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return console.log.apply(console, ['sew', version].concat(slice.call(args)));
};

log('service worker', version);

importScripts('serviceworker-cache-polyfill.js');

cache_version = 1;

current_caches = {
  psl: 'psl-v-' + cache_version
};

self.addEventListener('install', function(event) {
  return log('install', event);
});

self.addEventListener('activate', function(event) {
  var pslcache;
  log('activate', event);
  return pslcache = caches.open(current_caches.psl);
});

self.addEventListener('fetch', function(event) {
  var url;
  url = event.request.url;
  log('fetch', url);
  event.respondWith(caches.match(event.request).then(function(response) {
    console.log('Matched ', response);
    return response || fetch(event.request);
  }));
  return caches.open(current_caches.psl).then(function(cache) {
    var fr, req;
    cache.match(event.request).then(function(response) {
      console.log('Matched ', response);
      if (typeof response !== 'undefined') {
        return event.respondWith(response);
      }
    });
    return;
    if (true) {
      if (true) {
        req = event.request.clone();
        console.log('req clone: ', req);
        fr = fetch(req).then(function(response) {
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          return response.json();
        });
        return fr.then(function(urls) {
          console.log('URLS', urls);
          cache.addAll(urls);
          cache.put('http://localhost:5050/fake.html', new Response('<h1>Fake HTML</h1>'));
        });
      }
    }
  });
});

self.addEventListener('message', function(event) {
  console.log('message', event.data);
  return caches.open(current_caches.psl).then(function(cache) {
    var cmd;
    cmd = (function() {
      switch (event.data.command) {
        case 'keys':
          return function() {
            log('keys');
            return cache.keys().then(function(requests) {
              var urls;
              urls = requests.map(function(request) {
                return request.url;
              });
              return event.ports[0].postMessage({
                error: null,
                urls: urls.sort()
              });
            });
          };
        case 'add':
          return function() {
            var request;
            log('add', event.data.url);
            request = new Request(event.data.url);
            if (event.data.content === null) {
              return cache.add(request).then(function() {
                return event.ports[0].postMessage({
                  error: null
                });
              });
            } else {
              return cache.put(event.data.url, new Response(event.data.content)).then(function() {
                return event.ports[0].postMessage({
                  error: null
                });
              });
            }
          };
        case 'delete':
          return function() {
            var request;
            log('del', event.data.url);
            request = new Request(event.data.url);
            return cache["delete"](request).then(function(success) {
              return event.ports[0].postMessage({
                error: success != null ? success : {
                  "null": 'Item not in cache' + event.data.url
                }
              });
            });
          };
        default:
          return function() {
            return null;
          };
      }
    })();
    console.log(cmd);
    return cmd();
  });
});

//# sourceMappingURL=service-worker.js.map
